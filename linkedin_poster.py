"""
LinkedIn Poster for AI Employee

Automatically posts business updates to LinkedIn to generate sales.
"""

import time
import requests
from pathlib import Path
from datetime import datetime
import json
import os
import random


class LinkedInPoster:
    """Posts business updates to LinkedIn to generate sales."""

    def __init__(self, vault_path, linkedin_credentials=None):
        self.vault_path = Path(vault_path)
        self.plans_dir = self.vault_path / 'Plans'
        self.pending_approval = self.vault_path / 'Pending_Approval'
        self.linkedin_credentials = linkedin_credentials or {}
        self.session = requests.Session()

        # Create directories if they don't exist
        self.plans_dir.mkdir(parents=True, exist_ok=True)
        self.pending_approval.mkdir(parents=True, exist_ok=True)

        # Headers to mimic a real browser
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
        }

        # Business post templates
        self.post_templates = [
            {
                "title": "Exciting Project Update!",
                "content": "We're thrilled to share that we've just completed another successful project for a valued client. Our team's dedication to quality and innovation continues to drive results. Ready to take your business to the next level? Let's talk!",
                "hashtags": "#Business #Innovation #Success #ProjectManagement"
            },
            {
                "title": "Industry Insights",
                "content": "The landscape is evolving rapidly. At our company, we stay ahead by constantly adapting and innovating. Want to know how we can help you navigate the changes? Connect with us to explore possibilities.",
                "hashtags": "#IndustryInsights #Innovation #Adaptation #BusinessStrategy"
            },
            {
                "title": "Client Success Story",
                "content": "Just wrapped up a fantastic collaboration with [Client Name]. Their transformation journey has been incredible to witness. We love being part of our clients' success stories. What could we achieve together?",
                "hashtags": "#ClientSuccess #Transformation #Collaboration #Results"
            },
            {
                "title": "Behind the Scenes",
                "content": "Ever wonder what goes on behind the scenes? Our team combines creativity, strategy, and technology to deliver outstanding results. Curious about how we could apply our expertise to your challenges?",
                "hashtags": "#BehindTheScenes #Teamwork #Creativity #Technology"
            }
        ]

    def generate_business_post(self):
        """Generate a business post based on templates."""
        template = random.choice(self.post_templates)

        post_content = {
            'title': template['title'],
            'content': template['content'],
            'hashtags': template['hashtags'],
            'timestamp': datetime.now().isoformat()
        }

        return post_content

    def create_post_plan(self, post_content):
        """Create a plan for the LinkedIn post."""
        plan_content = f"""---
type: linkedin_post_plan
status: pending_approval
created_at: {post_content['timestamp']}
scheduled_for: {datetime.now().isoformat()}
title: {post_content['title']}
---

# LinkedIn Post Plan

## Post Content
{post_content['content']}

## Hashtags
{post_content['hashtags']}

## Target Audience
- Industry professionals
- Potential clients
- Business partners
- Relevant community members

## Expected Outcomes
- Increase brand visibility
- Generate leads
- Engage with target audience
- Drive traffic to business

## Approval Required
This post requires human approval before publishing. Please review the content and move to Approved folder to publish.

---
LinkedIn post plan generated by AI Employee
"""

        plan_filename = f"LINKEDIN_POST_PLAN_{int(datetime.now().timestamp())}.md"
        plan_file_path = self.plans_dir / plan_filename
        plan_file_path.write_text(plan_content)

        print(f"Created LinkedIn post plan: {plan_file_path}")
        return plan_file_path

    def create_approval_request(self, plan_file_path, post_content):
        """Create an approval request for the LinkedIn post."""
        approval_content = f"""---
type: approval_request
action: linkedin_post
plan_file: {plan_file_path.name}
status: pending
created_at: {post_content['timestamp']}
expires_at: {datetime.fromtimestamp(datetime.now().timestamp() + 86400).isoformat()}  # Expires in 24 hours
---

# LinkedIn Post Approval Request

## Post Title
{post_content['title']}

## Post Content
{post_content['content']}

## Hashtags
{post_content['hashtags']}

## To Approve
Move this file to /Approved folder to publish the post.

## To Reject
Move this file to /Rejected folder.

---
LinkedIn post approval request created by AI Employee
"""

        approval_filename = f"APPROVAL_LINKEDIN_POST_{int(datetime.now().timestamp())}.md"
        approval_file_path = self.pending_approval / approval_filename
        approval_file_path.write_text(approval_content)

        print(f"Created LinkedIn post approval request: {approval_file_path}")
        return approval_file_path

    def post_to_linkedin(self, post_content):
        """Actually post to LinkedIn (simulated for this implementation)."""
        # In a real implementation, this would use the LinkedIn API
        # to actually post the content to LinkedIn
        print(f"Simulating LinkedIn post: {post_content['title']}")
        print(f"Content: {post_content['content']}")
        print("Post published to LinkedIn!")

        # Log the posting activity
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': 'linkedin_post',
            'title': post_content['title'],
            'status': 'published'
        }

        # Write to logs
        logs_dir = self.vault_path / 'Logs'
        logs_dir.mkdir(exist_ok=True)
        log_file = logs_dir / f"linkedin_logs_{datetime.now().strftime('%Y-%m-%d')}.json"

        # Load existing logs if they exist
        logs = []
        if log_file.exists():
            try:
                logs = json.loads(log_file.read_text())
                if isinstance(logs, dict):  # If single object, wrap in list
                    logs = [logs]
            except json.JSONDecodeError:
                logs = []

        logs.append(log_entry)
        log_file.write_text(json.dumps(logs, indent=2))

        return True

    def check_for_approved_posts(self):
        """Check for approved LinkedIn posts to publish."""
        approved_dir = self.vault_path / 'Approved'
        if not approved_dir.exists():
            return []

        approved_posts = []
        for file_path in approved_dir.glob("APPROVAL_LINKEDIN_POST_*.md"):
            # Read the approval file to get the associated plan
            content = file_path.read_text()

            # Extract plan file name from the approval file
            import re
            plan_match = re.search(r'plan_file: (.+)', content)
            if plan_match:
                plan_filename = plan_match.group(1).strip()

                # Find the associated plan file
                plan_file_path = self.plans_dir / plan_filename
                if plan_file_path.exists():
                    plan_content = plan_file_path.read_text()

                    # Extract post content from plan
                    title_match = re.search(r'## Post Title\n(.+?)\n', plan_content)
                    content_match = re.search(r'## Post Content\n(.+?)\n', plan_content, re.DOTALL)
                    hashtags_match = re.search(r'## Hashtags\n(.+?)\n', plan_content)

                    if title_match and content_match:
                        post_data = {
                            'title': title_match.group(1).strip(),
                            'content': content_match.group(1).strip(),
                            'hashtags': hashtags_match.group(1).strip() if hashtags_match else '',
                            'plan_file': plan_file_path,
                            'approval_file': file_path
                        }
                        approved_posts.append(post_data)

        return approved_posts

    def publish_approved_posts(self):
        """Publish all approved LinkedIn posts."""
        approved_posts = self.check_for_approved_posts()
        published_count = 0

        for post_data in approved_posts:
            try:
                # Publish the post
                success = self.post_to_linkedin({
                    'title': post_data['title'],
                    'content': post_data['content'],
                    'hashtags': post_data['hashtags'],
                    'timestamp': datetime.now().isoformat()
                })

                if success:
                    # Move approval file to Done after successful posting
                    done_dir = self.vault_path / 'Done'
                    done_dir.mkdir(exist_ok=True)

                    # Move approval file to Done
                    done_approval_path = done_dir / f"DONE_{post_data['approval_file'].name}"
                    post_data['approval_file'].rename(done_approval_path)

                    # Move plan file to Done
                    done_plan_path = done_dir / f"DONE_{post_data['plan_file'].name}"
                    post_data['plan_file'].rename(done_plan_path)

                    print(f"Published and moved files for post: {post_data['title']}")
                    published_count += 1

            except Exception as e:
                print(f"Error publishing post {post_data['title']}: {e}")

        return published_count

    def run_auto_post_cycle(self):
        """Run a cycle of generating and planning LinkedIn posts."""
        print("Running LinkedIn auto-post cycle...")

        # Generate a new business post
        post_content = self.generate_business_post()

        # Create a plan for the post
        plan_file = self.create_post_plan(post_content)

        # Create an approval request
        approval_file = self.create_approval_request(plan_file, post_content)

        print(f"Created LinkedIn post plan and approval request")
        return plan_file, approval_file

    def run(self, post_interval=3600):  # Post approximately every hour
        """Run the LinkedIn poster continuously."""
        print("Starting LinkedIn Poster...")
        print(f"Generating posts every {post_interval} seconds")

        while True:
            try:
                # Run a posting cycle
                self.run_auto_post_cycle()

                # Check for and publish any approved posts
                published = self.publish_approved_posts()
                if published > 0:
                    print(f"Published {published} approved posts")

                print(f"LinkedIn poster cycle completed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

            except KeyboardInterrupt:
                print("\nLinkedIn Poster stopped by user.")
                break
            except Exception as e:
                print(f"Error in LinkedIn Poster: {e}")

            time.sleep(post_interval)


def main():
    """Main function to run the LinkedIn poster."""
    import sys

    if len(sys.argv) < 2:
        print("Usage: python linkedin_poster.py <vault_path>")
        print("Example: python linkedin_poster.py ./AI_Employee_Vault")
        return

    vault_path = sys.argv[1]

    poster = LinkedInPoster(vault_path)

    # For testing, just run one cycle
    if '--test' in sys.argv:
        print("Running LinkedIn poster test...")
        plan_file, approval_file = poster.run_auto_post_cycle()
        print("Test completed.")
    else:
        # Run continuously
        post_interval = 3600  # 1 hour
        if '--interval' in sys.argv:
            idx = sys.argv.index('--interval')
            if idx + 1 < len(sys.argv):
                post_interval = int(sys.argv[idx + 1])

        poster.run(post_interval)


if __name__ == "__main__":
    main()